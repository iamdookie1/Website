<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Digital Drawing Studio</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700;900&family=Lexend:wght@300;400;500&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --bg-dark: #0a0e17;
      --bg-card: #151b2b;
      --bg-hover: #1f2937;
      --accent-primary: #00d4ff;
      --accent-secondary: #ff0080;
      --accent-tertiary: #ffaa00;
      --text-primary: #ffffff;
      --text-secondary: #94a3b8;
      --border-color: #2d3748;
    }

    body {
      font-family: 'Lexend', sans-serif;
      background: linear-gradient(135deg, var(--bg-dark) 0%, #0f1420 100%);
      color: var(--text-primary);
      overflow: hidden;
      height: 100vh;
    }

    /* Start Menu Styles */
    .start-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #0a0e17 0%, #1a1f2e 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      opacity: 1;
      transition: opacity 0.5s ease;
    }

    .start-screen.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .start-content {
      text-align: center;
      animation: fadeInUp 0.8s ease;
    }

    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .start-title {
      font-family: 'Orbitron', sans-serif;
      font-size: 4rem;
      font-weight: 900;
      background: linear-gradient(135deg, var(--accent-primary) 0%, var(--accent-secondary) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 1rem;
      letter-spacing: 2px;
    }

    .start-subtitle {
      font-size: 1.2rem;
      color: var(--text-secondary);
      margin-bottom: 3rem;
      font-weight: 300;
    }

    .start-button {
      font-family: 'Orbitron', sans-serif;
      background: linear-gradient(135deg, var(--accent-primary) 0%, var(--accent-secondary) 100%);
      border: none;
      padding: 1.2rem 3rem;
      font-size: 1.2rem;
      font-weight: 700;
      color: white;
      cursor: pointer;
      border-radius: 50px;
      transition: all 0.3s ease;
      box-shadow: 0 10px 40px rgba(0, 212, 255, 0.3);
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .start-button:hover {
      transform: translateY(-3px);
      box-shadow: 0 15px 50px rgba(0, 212, 255, 0.5);
    }

    /* Main App Container */
    .app-container {
      display: flex;
      height: 100vh;
      opacity: 0;
      transition: opacity 0.5s ease 0.3s;
    }

    .app-container.visible {
      opacity: 1;
    }

    /* Toolbar */
    .toolbar {
      width: 320px;
      background: var(--bg-card);
      border-right: 2px solid var(--border-color);
      padding: 1.5rem;
      overflow-y: auto;
      box-shadow: 5px 0 20px rgba(0, 0, 0, 0.3);
    }

    .toolbar::-webkit-scrollbar {
      width: 8px;
    }

    .toolbar::-webkit-scrollbar-track {
      background: var(--bg-dark);
    }

    .toolbar::-webkit-scrollbar-thumb {
      background: var(--accent-primary);
      border-radius: 4px;
    }

    .toolbar-section {
      margin-bottom: 2rem;
      animation: slideInLeft 0.5s ease;
      animation-fill-mode: both;
    }

    .toolbar-section:nth-child(1) { animation-delay: 0.1s; }
    .toolbar-section:nth-child(2) { animation-delay: 0.2s; }
    .toolbar-section:nth-child(3) { animation-delay: 0.3s; }
    .toolbar-section:nth-child(4) { animation-delay: 0.4s; }
    .toolbar-section:nth-child(5) { animation-delay: 0.5s; }

    @keyframes slideInLeft {
      from {
        opacity: 0;
        transform: translateX(-20px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    .section-title {
      font-family: 'Orbitron', sans-serif;
      font-size: 0.9rem;
      font-weight: 700;
      color: var(--accent-primary);
      margin-bottom: 1rem;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    /* Tool Buttons */
    .tool-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 0.5rem;
    }

    .tool-btn {
      background: var(--bg-dark);
      border: 2px solid var(--border-color);
      padding: 0.8rem;
      cursor: pointer;
      border-radius: 8px;
      transition: all 0.2s ease;
      color: var(--text-secondary);
      font-size: 0.85rem;
      font-weight: 500;
      text-align: center;
    }

    .tool-btn:hover {
      border-color: var(--accent-primary);
      background: var(--bg-hover);
      transform: translateY(-2px);
    }

    .tool-btn.active {
      background: linear-gradient(135deg, var(--accent-primary) 0%, var(--accent-secondary) 100%);
      border-color: var(--accent-primary);
      color: white;
      box-shadow: 0 5px 20px rgba(0, 212, 255, 0.3);
    }

    /* Sliders */
    .control-group {
      margin-bottom: 1rem;
    }

    .control-label {
      display: flex;
      justify-content: space-between;
      margin-bottom: 0.5rem;
      font-size: 0.85rem;
      color: var(--text-secondary);
    }

    .control-value {
      color: var(--accent-primary);
      font-weight: 500;
    }

    input[type="range"] {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: var(--bg-dark);
      outline: none;
      -webkit-appearance: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--accent-primary) 0%, var(--accent-secondary) 100%);
      cursor: pointer;
      box-shadow: 0 2px 10px rgba(0, 212, 255, 0.5);
    }

    input[type="range"]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--accent-primary) 0%, var(--accent-secondary) 100%);
      cursor: pointer;
      border: none;
    }

    /* Color Picker */
    .color-picker-container {
      display: flex;
      gap: 1rem;
      align-items: center;
    }

    input[type="color"] {
      width: 60px;
      height: 60px;
      border: 3px solid var(--border-color);
      border-radius: 8px;
      cursor: pointer;
      background: transparent;
    }

    input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
    }

    input[type="color"]::-webkit-color-swatch {
      border: none;
      border-radius: 5px;
    }

    .color-presets {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 0.5rem;
      flex: 1;
    }

    .color-preset {
      width: 100%;
      aspect-ratio: 1;
      border: 2px solid var(--border-color);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .color-preset:hover {
      transform: scale(1.1);
      border-color: var(--accent-primary);
    }

    /* Action Buttons */
    .action-buttons {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 0.5rem;
    }

    .action-btn {
      background: var(--bg-dark);
      border: 2px solid var(--border-color);
      padding: 0.8rem;
      cursor: pointer;
      border-radius: 8px;
      transition: all 0.2s ease;
      color: var(--text-primary);
      font-size: 0.85rem;
      font-weight: 500;
    }

    .action-btn:hover {
      border-color: var(--accent-primary);
      background: var(--bg-hover);
    }

    .action-btn.danger:hover {
      border-color: var(--accent-secondary);
      background: rgba(255, 0, 128, 0.1);
    }

    /* Checkbox */
    .checkbox-group {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.8rem;
      cursor: pointer;
    }

    .checkbox-group input[type="checkbox"] {
      width: 18px;
      height: 18px;
      cursor: pointer;
      accent-color: var(--accent-primary);
    }

    .checkbox-group label {
      font-size: 0.85rem;
      color: var(--text-secondary);
      cursor: pointer;
    }

    /* Canvas Container */
    .canvas-container {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2rem;
      position: relative;
    }

    #drawingCanvas {
      border: 2px solid var(--border-color);
      border-radius: 8px;
      cursor: crosshair;
      box-shadow: 0 10px 50px rgba(0, 0, 0, 0.5);
      background: white;
    }

    /* Canvas Info */
    .canvas-info {
      position: absolute;
      top: 2rem;
      right: 2rem;
      background: rgba(21, 27, 43, 0.9);
      backdrop-filter: blur(10px);
      padding: 1rem 1.5rem;
      border-radius: 8px;
      border: 2px solid var(--border-color);
      font-size: 0.85rem;
      color: var(--text-secondary);
    }

    /* Loading Overlay */
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(10, 14, 23, 0.95);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }

    .loading-overlay.active {
      display: flex;
    }

    .spinner {
      width: 50px;
      height: 50px;
      border: 4px solid var(--bg-card);
      border-top: 4px solid var(--accent-primary);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Select Dropdown */
    select {
      width: 100%;
      padding: 0.8rem;
      background: var(--bg-dark);
      border: 2px solid var(--border-color);
      border-radius: 8px;
      color: var(--text-primary);
      font-size: 0.85rem;
      cursor: pointer;
    }

    select:focus {
      outline: none;
      border-color: var(--accent-primary);
    }

    option {
      background: var(--bg-dark);
      color: var(--text-primary);
    }
  </style>
</head>
<body>
  <!-- Start Screen -->
  <div id="startScreen" class="start-screen">
    <div class="start-content">
      <h1 class="start-title">DIGITAL STUDIO</h1>
      <p class="start-subtitle">Professional Drawing & Painting Application</p>
      <button class="start-button" onclick="startApp()">CREATE</button>
    </div>
  </div>

  <!-- Loading Overlay -->
  <div id="loadingOverlay" class="loading-overlay">
    <div class="spinner"></div>
  </div>

  <!-- Main App -->
  <div id="app" class="app-container">
    <!-- Toolbar -->
    <div class="toolbar">
      <!-- Tools Section -->
      <div class="toolbar-section">
        <h3 class="section-title">üé® Drawing Tools</h3>
        <div class="tool-grid">
          <button class="tool-btn active" data-tool="brush">Brush</button>
          <button class="tool-btn" data-tool="eraser">Eraser</button>
          <button class="tool-btn" data-tool="mix">Mix</button>
          <button class="tool-btn" data-tool="spray">Spray</button>
          <button class="tool-btn" data-tool="fill">Fill</button>
          <button class="tool-btn" data-tool="eyedropper">Dropper</button>
          <button class="tool-btn" data-tool="line">Line</button>
          <button class="tool-btn" data-tool="rectangle">Rectangle</button>
          <button class="tool-btn" data-tool="circle">Circle</button>
        </div>
      </div>

      <!-- Brush Settings -->
      <div class="toolbar-section">
        <h3 class="section-title">‚úèÔ∏è Brush Settings</h3>
        
        <div class="control-group">
          <div class="control-label">
            <span>Size</span>
            <span class="control-value" id="sizeValue">20</span>
          </div>
          <input type="range" id="brushSize" min="1" max="100" value="20">
        </div>

        <div class="control-group">
          <div class="control-label">
            <span>Opacity</span>
            <span class="control-value" id="opacityValue">100%</span>
          </div>
          <input type="range" id="brushOpacity" min="1" max="100" value="100">
        </div>

        <div class="control-group">
          <div class="control-label">
            <span>Hardness</span>
            <span class="control-value" id="hardnessValue">50%</span>
          </div>
          <input type="range" id="brushHardness" min="0" max="100" value="50">
        </div>

        <div class="control-group">
          <div class="control-label">
            <span>Smoothing</span>
            <span class="control-value" id="smoothingValue">50%</span>
          </div>
          <input type="range" id="brushSmoothing" min="0" max="100" value="50">
        </div>
      </div>

      <!-- Color Settings -->
      <div class="toolbar-section">
        <h3 class="section-title">üé® Color</h3>
        
        <div class="color-picker-container">
          <input type="color" id="colorPicker" value="#00d4ff">
          <div class="color-presets">
            <div class="color-preset" style="background: #ff0080;" data-color="#ff0080"></div>
            <div class="color-preset" style="background: #00d4ff;" data-color="#00d4ff"></div>
            <div class="color-preset" style="background: #ffaa00;" data-color="#ffaa00"></div>
            <div class="color-preset" style="background: #00ff88;" data-color="#00ff88"></div>
            <div class="color-preset" style="background: #ff3366;" data-color="#ff3366"></div>
            <div class="color-preset" style="background: #9966ff;" data-color="#9966ff"></div>
            <div class="color-preset" style="background: #ffffff;" data-color="#ffffff"></div>
            <div class="color-preset" style="background: #000000;" data-color="#000000"></div>
          </div>
        </div>
      </div>

      <!-- Effects -->
      <div class="toolbar-section">
        <h3 class="section-title">‚ú® Effects</h3>
        
        <div class="control-group">
          <div class="control-label">
            <span>Glow Intensity</span>
            <span class="control-value" id="glowValue">0</span>
          </div>
          <input type="range" id="glowIntensity" min="0" max="50" value="0">
        </div>

        <div class="control-group">
          <div class="control-label">
            <span>Blur Amount</span>
            <span class="control-value" id="blurValue">0</span>
          </div>
          <input type="range" id="blurAmount" min="0" max="20" value="0">
        </div>
      </div>

      <!-- Canvas Settings -->
      <div class="toolbar-section">
        <h3 class="section-title">‚öôÔ∏è Canvas Settings</h3>
        
        <div class="control-group">
          <label class="control-label">Background Color</label>
          <input type="color" id="bgColor" value="#ffffff" style="width: 100%;">
        </div>

        <div class="control-group">
          <label class="control-label">Canvas Size</label>
          <select id="canvasSize">
            <option value="800,600">800 √ó 600 (Standard)</option>
            <option value="1024,768">1024 √ó 768 (XGA)</option>
            <option value="1280,720">1280 √ó 720 (HD)</option>
            <option value="1920,1080">1920 √ó 1080 (Full HD)</option>
            <option value="2560,1440">2560 √ó 1440 (2K)</option>
          </select>
        </div>

        <div class="checkbox-group">
          <input type="checkbox" id="showGrid">
          <label for="showGrid">Show Grid</label>
        </div>

        <div class="checkbox-group">
          <input type="checkbox" id="symmetryMode">
          <label for="symmetryMode">Symmetry Mode</label>
        </div>

        <div class="checkbox-group">
          <input type="checkbox" id="pressureSim">
          <label for="pressureSim">Pressure Simulation</label>
        </div>
      </div>

      <!-- Actions -->
      <div class="toolbar-section">
        <h3 class="section-title">üíæ Actions</h3>
        
        <div class="action-buttons">
          <button class="action-btn" onclick="undo()">‚Ü©Ô∏è Undo</button>
          <button class="action-btn" onclick="redo()">‚Ü™Ô∏è Redo</button>
          <button class="action-btn" onclick="clearCanvas()">üóëÔ∏è Clear</button>
          <button class="action-btn danger" onclick="resetAll()">üîÑ Reset</button>
          <button class="action-btn" onclick="savePNG()">üíæ Save PNG</button>
          <button class="action-btn" onclick="saveJPG()">üíæ Save JPG</button>
          <button class="action-btn" onclick="loadImage()">üìÅ Load</button>
          <button class="action-btn" onclick="downloadProject()">üì¶ Export</button>
        </div>
      </div>
    </div>

    <!-- Canvas Area -->
    <div class="canvas-container">
      <canvas id="drawingCanvas" width="800" height="600"></canvas>
      <div class="canvas-info">
        <div>Position: <span id="mousePos">0, 0</span></div>
        <div>Tool: <span id="currentTool">Brush</span></div>
      </div>
    </div>
  </div>

  <script>
    // Application State
    const state = {
      currentTool: 'brush',
      brushSize: 20,
      brushOpacity: 1,
      brushHardness: 0.5,
      brushSmoothing: 0.5,
      color: '#00d4ff',
      glowIntensity: 0,
      blurAmount: 0,
      isDrawing: false,
      lastX: 0,
      lastY: 0,
      showGrid: false,
      symmetryMode: false,
      pressureSim: false,
      history: [],
      historyStep: -1,
      smoothPoints: [],
      bgColor: '#ffffff'
    };

    // Canvas Setup
    const canvas = document.getElementById('drawingCanvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    
    // Initialize
    function startApp() {
      document.getElementById('startScreen').classList.add('hidden');
      setTimeout(() => {
        document.getElementById('app').classList.add('visible');
        initializeCanvas();
        saveState();
      }, 500);
    }

    function initializeCanvas() {
      ctx.fillStyle = state.bgColor;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    // Tool Selection
    document.querySelectorAll('.tool-btn').forEach(btn => {
      btn.addEventListener('click', function() {
        document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
        state.currentTool = this.dataset.tool;
        document.getElementById('currentTool').textContent = this.textContent;
      });
    });

    // Brush Size
    document.getElementById('brushSize').addEventListener('input', function() {
      state.brushSize = parseInt(this.value);
      document.getElementById('sizeValue').textContent = this.value;
    });

    // Brush Opacity
    document.getElementById('brushOpacity').addEventListener('input', function() {
      state.brushOpacity = parseInt(this.value) / 100;
      document.getElementById('opacityValue').textContent = this.value + '%';
    });

    // Brush Hardness
    document.getElementById('brushHardness').addEventListener('input', function() {
      state.brushHardness = parseInt(this.value) / 100;
      document.getElementById('hardnessValue').textContent = this.value + '%';
    });

    // Brush Smoothing
    document.getElementById('brushSmoothing').addEventListener('input', function() {
      state.brushSmoothing = parseInt(this.value) / 100;
      document.getElementById('smoothingValue').textContent = this.value + '%';
    });

    // Color Picker
    document.getElementById('colorPicker').addEventListener('input', function() {
      state.color = this.value;
    });

    // Color Presets
    document.querySelectorAll('.color-preset').forEach(preset => {
      preset.addEventListener('click', function() {
        const color = this.dataset.color;
        state.color = color;
        document.getElementById('colorPicker').value = color;
      });
    });

    // Glow Intensity
    document.getElementById('glowIntensity').addEventListener('input', function() {
      state.glowIntensity = parseInt(this.value);
      document.getElementById('glowValue').textContent = this.value;
    });

    // Blur Amount
    document.getElementById('blurAmount').addEventListener('input', function() {
      state.blurAmount = parseInt(this.value);
      document.getElementById('blurValue').textContent = this.value;
    });

    // Background Color
    document.getElementById('bgColor').addEventListener('input', function() {
      state.bgColor = this.value;
      redrawCanvas();
    });

    // Canvas Size
    document.getElementById('canvasSize').addEventListener('change', function() {
      const [width, height] = this.value.split(',').map(Number);
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      canvas.width = width;
      canvas.height = height;
      ctx.fillStyle = state.bgColor;
      ctx.fillRect(0, 0, width, height);
      ctx.putImageData(imageData, 0, 0);
      saveState();
    });

    // Grid Toggle
    document.getElementById('showGrid').addEventListener('change', function() {
      state.showGrid = this.checked;
      redrawCanvas();
    });

    // Symmetry Mode
    document.getElementById('symmetryMode').addEventListener('change', function() {
      state.symmetryMode = this.checked;
    });

    // Pressure Simulation
    document.getElementById('pressureSim').addEventListener('change', function() {
      state.pressureSim = this.checked;
    });

    // Drawing Functions
    function startDrawing(e) {
      state.isDrawing = true;
      const rect = canvas.getBoundingClientRect();
      state.lastX = e.clientX - rect.left;
      state.lastY = e.clientY - rect.top;
      state.smoothPoints = [{x: state.lastX, y: state.lastY}];

      if (state.currentTool === 'fill') {
        floodFill(state.lastX, state.lastY);
        saveState();
      } else if (state.currentTool === 'eyedropper') {
        pickColor(state.lastX, state.lastY);
      }
    }

    function draw(e) {
      if (!state.isDrawing) return;
      
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      // Update mouse position
      document.getElementById('mousePos').textContent = `${Math.round(x)}, ${Math.round(y)}`;

      // Add to smooth points
      state.smoothPoints.push({x, y});
      if (state.smoothPoints.length > 5) {
        state.smoothPoints.shift();
      }

      // Calculate smoothed position
      let smoothX = x, smoothY = y;
      if (state.brushSmoothing > 0 && state.smoothPoints.length > 1) {
        const weight = state.brushSmoothing;
        smoothX = state.smoothPoints.reduce((sum, p) => sum + p.x, 0) / state.smoothPoints.length;
        smoothY = state.smoothPoints.reduce((sum, p) => sum + p.y, 0) / state.smoothPoints.length;
        smoothX = x * (1 - weight) + smoothX * weight;
        smoothY = y * (1 - weight) + smoothY * weight;
      }

      // Pressure simulation
      let size = state.brushSize;
      if (state.pressureSim) {
        const speed = Math.sqrt(Math.pow(x - state.lastX, 2) + Math.pow(y - state.lastY, 2));
        const pressure = Math.max(0.3, 1 - Math.min(speed / 50, 0.7));
        size *= pressure;
      }

      // Apply tool
      switch (state.currentTool) {
        case 'brush':
          drawBrush(state.lastX, state.lastY, smoothX, smoothY, size);
          break;
        case 'eraser':
          drawEraser(state.lastX, state.lastY, smoothX, smoothY, size);
          break;
        case 'mix':
          drawMix(state.lastX, state.lastY, smoothX, smoothY, size);
          break;
        case 'spray':
          drawSpray(smoothX, smoothY, size);
          break;
        case 'line':
        case 'rectangle':
        case 'circle':
          // These are handled on mouseup
          break;
      }

      state.lastX = smoothX;
      state.lastY = smoothY;
    }

    function stopDrawing(e) {
      if (!state.isDrawing) return;
      
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      // Handle shape tools
      if (['line', 'rectangle', 'circle'].includes(state.currentTool)) {
        const startX = state.smoothPoints[0].x;
        const startY = state.smoothPoints[0].y;
        
        ctx.globalAlpha = state.brushOpacity;
        ctx.strokeStyle = state.color;
        ctx.lineWidth = state.brushSize;
        
        if (state.glowIntensity > 0) {
          ctx.shadowBlur = state.glowIntensity;
          ctx.shadowColor = state.color;
        }

        if (state.currentTool === 'line') {
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(x, y);
          ctx.stroke();
        } else if (state.currentTool === 'rectangle') {
          ctx.strokeRect(startX, startY, x - startX, y - startY);
        } else if (state.currentTool === 'circle') {
          const radius = Math.sqrt(Math.pow(x - startX, 2) + Math.pow(y - startY, 2));
          ctx.beginPath();
          ctx.arc(startX, startY, radius, 0, Math.PI * 2);
          ctx.stroke();
        }

        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1;
      }

      state.isDrawing = false;
      state.smoothPoints = [];
      saveState();
    }

    function drawBrush(x1, y1, x2, y2, size) {
      ctx.globalAlpha = state.brushOpacity;
      ctx.strokeStyle = state.color;
      ctx.fillStyle = state.color;
      ctx.lineWidth = size;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';

      if (state.glowIntensity > 0) {
        ctx.shadowBlur = state.glowIntensity;
        ctx.shadowColor = state.color;
      }

      if (state.blurAmount > 0) {
        ctx.filter = `blur(${state.blurAmount}px)`;
      }

      // Create gradient for hardness
      if (state.brushHardness < 1) {
        const gradient = ctx.createRadialGradient(x2, y2, 0, x2, y2, size / 2);
        gradient.addColorStop(0, state.color);
        gradient.addColorStop(state.brushHardness, state.color);
        gradient.addColorStop(1, state.color + '00');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x2, y2, size / 2, 0, Math.PI * 2);
        ctx.fill();
      } else {
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
      }

      // Symmetry
      if (state.symmetryMode) {
        const centerX = canvas.width / 2;
        const mirrorX1 = centerX - (x1 - centerX);
        const mirrorX2 = centerX - (x2 - centerX);
        
        if (state.brushHardness < 1) {
          const gradient = ctx.createRadialGradient(mirrorX2, y2, 0, mirrorX2, y2, size / 2);
          gradient.addColorStop(0, state.color);
          gradient.addColorStop(state.brushHardness, state.color);
          gradient.addColorStop(1, state.color + '00');
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(mirrorX2, y2, size / 2, 0, Math.PI * 2);
          ctx.fill();
        } else {
          ctx.beginPath();
          ctx.moveTo(mirrorX1, y1);
          ctx.lineTo(mirrorX2, y2);
          ctx.stroke();
        }
      }

      ctx.shadowBlur = 0;
      ctx.filter = 'none';
      ctx.globalAlpha = 1;
    }

    function drawEraser(x1, y1, x2, y2, size) {
      ctx.globalCompositeOperation = 'destination-out';
      ctx.globalAlpha = state.brushOpacity;
      ctx.lineWidth = size;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
      ctx.globalCompositeOperation = 'source-over';
      ctx.globalAlpha = 1;
    }

    function drawMix(x1, y1, x2, y2, size) {
      // Get pixel data
      const imageData = ctx.getImageData(x2 - size/2, y2 - size/2, size, size);
      const data = imageData.data;
      
      // Average colors
      let r = 0, g = 0, b = 0, count = 0;
      for (let i = 0; i < data.length; i += 4) {
        r += data[i];
        g += data[i + 1];
        b += data[i + 2];
        count++;
      }
      
      const avgColor = `rgb(${Math.round(r/count)}, ${Math.round(g/count)}, ${Math.round(b/count)})`;
      
      ctx.globalAlpha = state.brushOpacity * 0.3;
      ctx.fillStyle = avgColor;
      ctx.beginPath();
      ctx.arc(x2, y2, size / 2, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    function drawSpray(x, y, size) {
      const density = 50;
      ctx.globalAlpha = state.brushOpacity * 0.1;
      ctx.fillStyle = state.color;
      
      for (let i = 0; i < density; i++) {
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.random() * size / 2;
        const px = x + Math.cos(angle) * radius;
        const py = y + Math.sin(angle) * radius;
        
        ctx.beginPath();
        ctx.arc(px, py, 1, 0, Math.PI * 2);
        ctx.fill();
      }
      
      ctx.globalAlpha = 1;
    }

    function floodFill(startX, startY) {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      
      const startPos = (Math.floor(startY) * canvas.width + Math.floor(startX)) * 4;
      const startR = data[startPos];
      const startG = data[startPos + 1];
      const startB = data[startPos + 2];
      
      const fillColor = hexToRgb(state.color);
      
      if (startR === fillColor.r && startG === fillColor.g && startB === fillColor.b) return;
      
      const stack = [[Math.floor(startX), Math.floor(startY)]];
      
      while (stack.length > 0) {
        const [x, y] = stack.pop();
        const pos = (y * canvas.width + x) * 4;
        
        if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) continue;
        if (data[pos] !== startR || data[pos + 1] !== startG || data[pos + 2] !== startB) continue;
        
        data[pos] = fillColor.r;
        data[pos + 1] = fillColor.g;
        data[pos + 2] = fillColor.b;
        data[pos + 3] = 255;
        
        stack.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
      }
      
      ctx.putImageData(imageData, 0, 0);
    }

    function pickColor(x, y) {
      const imageData = ctx.getImageData(x, y, 1, 1);
      const data = imageData.data;
      const color = rgbToHex(data[0], data[1], data[2]);
      state.color = color;
      document.getElementById('colorPicker').value = color;
    }

    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
      } : null;
    }

    function rgbToHex(r, g, b) {
      return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    }

    // History Management
    function saveState() {
      state.historyStep++;
      if (state.historyStep < state.history.length) {
        state.history.length = state.historyStep;
      }
      state.history.push(canvas.toDataURL());
      if (state.history.length > 50) {
        state.history.shift();
        state.historyStep--;
      }
    }

    function undo() {
      if (state.historyStep > 0) {
        state.historyStep--;
        const img = new Image();
        img.onload = function() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(img, 0, 0);
        };
        img.src = state.history[state.historyStep];
      }
    }

    function redo() {
      if (state.historyStep < state.history.length - 1) {
        state.historyStep++;
        const img = new Image();
        img.onload = function() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(img, 0, 0);
        };
        img.src = state.history[state.historyStep];
      }
    }

    function clearCanvas() {
      if (confirm('Clear the entire canvas?')) {
        ctx.fillStyle = state.bgColor;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        saveState();
      }
    }

    function resetAll() {
      if (confirm('Reset all settings and clear canvas?')) {
        location.reload();
      }
    }

    function redrawCanvas() {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = state.bgColor;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.putImageData(imageData, 0, 0);
      
      if (state.showGrid) {
        drawGrid();
      }
    }

    function drawGrid() {
      const gridSize = 50;
      ctx.strokeStyle = 'rgba(0, 212, 255, 0.2)';
      ctx.lineWidth = 1;
      
      for (let x = 0; x <= canvas.width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      
      for (let y = 0; y <= canvas.height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }
    }

    // Save Functions
    function savePNG() {
      const link = document.createElement('a');
      link.download = `artwork-${Date.now()}.png`;
      link.href = canvas.toDataURL('image/png');
      link.click();
    }

    function saveJPG() {
      const link = document.createElement('a');
      link.download = `artwork-${Date.now()}.jpg`;
      link.href = canvas.toDataURL('image/jpeg', 0.95);
      link.click();
    }

    function loadImage() {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'image/*';
      input.onchange = function(e) {
        const file = e.target.files[0];
        const reader = new FileReader();
        reader.onload = function(event) {
          const img = new Image();
          img.onload = function() {
            ctx.drawImage(img, 0, 0);
            saveState();
          };
          img.src = event.target.result;
        };
        reader.readAsDataURL(file);
      };
      input.click();
    }

    function downloadProject() {
      const projectData = {
        image: canvas.toDataURL(),
        settings: {
          brushSize: state.brushSize,
          brushOpacity: state.brushOpacity,
          brushHardness: state.brushHardness,
          color: state.color,
          bgColor: state.bgColor,
          canvasWidth: canvas.width,
          canvasHeight: canvas.height
        }
      };
      
      const blob = new Blob([JSON.stringify(projectData)], { type: 'application/json' });
      const link = document.createElement('a');
      link.download = `project-${Date.now()}.json`;
      link.href = URL.createObjectURL(blob);
      link.click();
    }

    // Event Listeners
    canvas.addEventListener('mousedown', startDrawing);
    canvas.addEventListener('mousemove', draw);
    canvas.addEventListener('mouseup', stopDrawing);
    canvas.addEventListener('mouseleave', stopDrawing);

    // Prevent context menu
    canvas.addEventListener('contextmenu', e => e.preventDefault());
  </script>
</body>
</html>
